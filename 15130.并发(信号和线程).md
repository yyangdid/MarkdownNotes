# 并发(信号，线程) _(LHQ 30.1 30.2)_

- 同步: 程序在什么时候执行时会遇到什么样的操作, 是可预见的.
- 异步: (并发)事件何时到来, 事件到来会产生什么结果都不能确定.
- 异步事件处理: (多核或多线程 cpu)
  - 查询法: 适合事件发生的频率比较密集的情况.
  - 通知法: 适合事件发生的频率比较稀疏的情况.

- **不要混用信号和线程**

## 信号

- 信号 + 多进程并发

### 信号的概念 _(LHQ 30.2)_

- 信号是软件层面的中断
  - 中断: 底层的, 硬件层的.
  - 信号: 软件层的.
  - 信号的响应依赖于中断.

- `kill -l` 命令
  - 查看当前系统的所有信号(kill 是 shell 的内置命令(也存在 /usr/bin/kill), zsh 和 shell 输出不同).
  - 1~31 号信号为标准信号, 从 34 号开始为实时信号.
  - Unix 信号列表及详细解释.(APUE, 第 10 章 信号, 10.2 信号概念)
  - `/usr/include/bits/signum.h` 和 `/usr/include/bits/signum-generic.h`

### `signal(2)` 函数 _(LHQ 30.3)_

- 信号会打断阻塞的系统调用.
- [示例: signal(2) 函数的使用 v1](./Atta/code/1117-use-signal/README.md#v1) _(LHQ 30.3)_
- [示例: signal(2) 函数的使用 v2](./Atta/code/1117-use-signal/README.md#v2) _(LHQ 30.3)_
- 该函数有重入的危险 [扩展 `sigaction(2)`](#扩展) _(LHQ 30.18(3:00))_
- 缺点 _(LHQ 30.18(18:00))_

### 信号的不可靠 _(LHQ 30.3)_

- 标准信号一定会丢失, 实时信号不会丢失.
- 这里说的不可靠指的是信号的行为不可靠.
  - 当一个信号正在进行处理的时候又来了一个相同的信号, 内核给这两个信号分配的执行现场有可能不是在同一
    个位置, 那么第二个信号的执行现场就会把前一个冲掉.

### 可重入函数 _(LHQ 30.4)_

- 为了解决信号的不可靠.
- 可重入函数: 一个函数第一个被调用还没有结束, 就发生了第二次对该函数的调用, 那么都不会出错.
- 所有的系统调用都是可重入的, 一部分库函数也是可重入的(比如 `memcpy(3)` 是可重入的, `rand(3)` 是不可
  重入的, 但是 `rand_r(3)` 是可重入的. 若一个函数有一个带 `_r` 的版本就表明这个函数是不可重入的, 带
  `_r` 的是可重入的版本).

- 使用信号的程序中尽量不用不可重入的函数.

### 信号的响应过程 _(LHQ 30.4 30.5)_

- 看视频
- 信号从收到到响应有一个不可避免的延迟.
- 思考:
  - 如何忽略掉一个信号的?
  - 标准信号为什么要丢失?
- 标准信号的响应没有严格的顺序.
- 不能从信号处理函数中随意的往外跳(`setjmp(3)` `longjmp(3)`), 若往外跳就会错过把 mask 改回去的机会(
  也不一定, 看视频).若往外跳需使用 `sigsetjmp(3)` `siglongjmp(3)`. _(LHQ 30.16)_

### 常用函数 _(LHQ 30.6)_

- `kill(2)`
- `raise(3)`
- `alarm(2)`
- `setitimer(2)` `getitimer(2)` _(LHQ 30.14)_
- `pause(2)` : 不能用作信号驱动程序, 因为不能原子操作, 需使用 `sigsuspend(2)` [扩展](#扩展). _(LHQ 30.17)_
- `abort(3)`
- `system(3)`
- `sleep(3)` _(LHQ 30.14)_
  - 尽量只在测试语句中使用 `sleep(3)`.
  - 正式代码中可以使用 `nanosleep(2)` 或 `usleep(3)` 代替, 或 使用 `select(2)` 函数的副作用.

- [示例: alarm(2) 函数的使用 v1](./Atta/code/1118-use-alarm/README.md#v1) _(LHQ 30.7)_
- [示例: alarm(2) 函数的使用 v2](./Atta/code/1118-use-alarm/README.md#v2) _(LHQ 30.7)_
- [示例: 简单的 cat 程序实现 v1](./Atta/code/1119-my-cat/README.md#v1) _(LHQ 30.7)_
- 流量控制, 流控, 漏桶
  - [示例: 简单的 cat 程序实现 v2](./Atta/code/1119-my-cat/README.md#v2) _(LHQ 30.8)_
- 流量控制, 流控, 令牌桶
  - [示例: 简单的 cat 程序实现 v3](./Atta/code/1119-my-cat/README.md#v3) _(LHQ 30.9)_
- 将令牌桶封装成库(令牌桶流量控制 Token Bucket Flow Control) _(LHQ 30.9 30.10 30.11)_
  - [示例: 令牌桶流量控制库 v1](./Atta/code/1120-my-token-bucket-flow-control-library/README.md#v1) _(LHQ 30.9 30.10 30.11)_

- [示例: 使用单一计时器, 构造一组函数, 实现任意数量的计时器 v1](./Atta/code/1121-any-timer/README.md#v1) _(LHQ 30.12 30.13)_
- [示例: 简单的 cat 程序实现 v5](./Atta/code/1119-my-cat/README.md#v5) _(LHQ 30.14)_

### 信号集 _(LHQ 30.15)_

- `sigset_t` : 信号集类型.
- `sigemptyset(3)`
- `sigfillset(3)`
- `sigaddset(3)`
- `sigdelset(3)`
- `sigismember(3)`

### 信号屏蔽字和信号 pending 集的处理 _(LHQ 30.15)_

- `mask` 反应要不要响应信号, `pending` 反应信号来没来. _(LHQ 30.16)_

- `sigprocmask(2)` : 不能决定信号什么来, 但是可以决定信号什么时候被响应.
  - [示例: sigprocmask(2) 函数的使用 v1](./Atta/code/1122-use-sigprocmask/README.md#v1) _(LHQ 30.15)_
  - [示例: sigprocmask(2) 函数的使用 v2](./Atta/code/1122-use-sigprocmask/README.md#v2) _(LHQ 30.15)_
  - [示例: sigprocmask(2) 函数的使用 v3](./Atta/code/1122-use-sigprocmask/README.md#v3) _(LHQ 30.15)_
  - [示例: sigprocmask(2) 函数的使用 v4](./Atta/code/1122-use-sigprocmask/README.md#v4) _(LHQ 30.15)_

- `sigpending(2)` : LHQ 也不知道该函数该用在哪. _(LHQ 30.16)_

### 扩展

- `setitimer(2)` `getitimer(2)` : [常用函数](#常用函数-lhq-306) _(LHQ 30.14)_
  - [示例: 简单的 cat 程序实现 v5](./Atta/code/1119-my-cat/README.md#v5) _(LHQ 30.14)_

- `sigsuspend(2)` 信号驱动.
  - [示例: sigsuspend(2) 函数的使用 v1](./Atta/code/1123-use-sigsuspend/README.md#v1) _(LHQ 30.17)_

- `sigaction(2)` : 用于替换 `signal(2)`
  - [示例: sigaction(2) 函数的使用 v1](./Atta/code/1124-use-sigaction/README.md#v1) _(LHQ 30.18)_
  - [示例: sigaction(2) 函数的使用 v2](./Atta/code/1124-use-sigaction/README.md#v2) _(LHQ 30.18)_
  - [示例: sigaction(2) 函数的使用 v3](./Atta/code/1124-use-sigaction/README.md#v3) _(LHQ 30.18 30.19)_

- 提到 _(LHQ 30.19(21:00))_
  - `getcontext(3)` `setcontext(3)`
    - 可以不借助调度器搭建出用户级的多线程框架.

### 实时信号 _(LHQ 30.20)_

- 实时信号不丢失
- 实时信号需要排队
- 实时信号的响应有顺序的
- 若一个进程既收到标准信号又收到实时信号, 那么先响应标准信号.
- `kill -l` 信号列表的 34~64 为实时信号.
- `ulimit -a` 中的 `pending signals` 为实时信号允许的最大排队数.
- [示例: sigsuspend(2) 函数的使用 v3](./Atta/code/1123-use-sigsuspend/README.md#v3) _(LHQ 30.20)_

## 线程 (多线程并发) _(LHQ 31.1)_

### 线程的概念 _(LHQ 31.1)_

- 线程就是一个正在运行的函数.
- 多个线程之间是兄弟关系.
- 多个线程的内存空间是共享的, 都在同一个进程空间内.
- POSIX 线程是一套标准, 而不是实现.
  - openmp 线程也是一种标准.
- `ps ax -L` 和 `ps axm` 查看进程线程关系.
- 线程的标识: `pthread_t`
- 编译时需添加链接参数 `-pthread`

- `pthread_equal(3)` : 比较线程标识.
- `pthread_self(3)` : 获取当前线程的标识(ID).

### 线程的创建, 终止和清理, 栈的清理, 取消选项 _(LHQ 31.2)_

#### 创建 _(LHQ 31.2)_

- `pthread_create(3)` : 创建一个线程.
- 线程的调度取决于调度器策略.
- [示例: 线程的基础使用 v1](./Atta/code/1125-thread-base/README.md#v1) _(LHQ 31.2)_

#### 终止和清理 _(LHQ 31.3)_

- 三种方式:
  - 线程从启动例程返回, 返回值就是线程的退出码.
  - 线程可以被同一进程中的其他线程取消.
  - 线程调用 `pthread_exit(3)` 函数.
    - [示例: 线程的基础使用 v2](./Atta/code/1125-thread-base/README.md#v2) _(LHQ 31.3)_
  - `pthread_join(3)` : 线程清理, 相当于进程的 `wait(2)`.
    - [示例: 线程的基础使用 v3](./Atta/code/1125-thread-base/README.md#v3) _(LHQ 31.3)_

#### 栈的清理 _(LHQ 31.3)_

- `pthread_cleanup_push(3)` `pthread_cleanup_pop(3)` : 类似钩子函数.
- [示例: 线程的栈清理 v1](./Atta/code/1126-thread-stack-cleanup/README.md#v1) _(LHQ 31.3)_

#### 取消选项 _(LHQ 31.4)_

- 一个线程在执行的过程中一定会用到线程取消.
- `pthread_cancel(3)`
- 先取消再清理.
- 取消有两种状态: 允许和不允许.
  - 允许取消又分为:
    - 异步 cancel.
    - 推迟 cancel(默认): 推迟到 cancel 点再响应.
      - POSIX 定义的 cancel 点都是可能引发阻塞的系统调用, 非系统调用是否是 cancel 点需要查手册.
  - `pthread_setcancelstate(3)` : 设置是否允许取消.
  - `pthread_setcanceltype(3)` : 设置取消方式.
  - `pthread_testcancel(3)` : 本函数什么都不做, 就是一个 cancel 点.

#### 线程分离 _(LHQ 31.4)_

- `pthread_detach(3)`
- 已经分离的不能被清理(join).

### 线程同步

### 线程属性, 线程同步属性

### 重入, 线程与信号, 线程与 `fork(2)`
