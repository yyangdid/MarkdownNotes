# 高级 I/O _(LHQ 32.1)_

## 非阻塞 I/O _(LHQ 32.1)_

- 阻塞 I/O：死心眼，必须读取到东西，要不我就一直等着。
- 非阻塞 I/O：大聪明，能读取到就读取到，读取不到我就走。
- 数据中继

## 有限状态机编程 _(LHQ 32.2)_

- 可以解决简单流程和复杂流程问题，主要是用来解决复杂流程问题的。可维护性非常高。
- 简单流程：如果一个程序的自然流程是结构化的，那么就叫简单流程。
  - 自然流程：就是作为人类来讲解决问题最简单最直观的思路。
    - 比如，大象装冰箱分为三步：
      - 一、打开冰箱门。
      - 二、把大象放进去。
      - 三、关上冰箱门。
- 复杂流程：如果一个程序的自然流程不是结构化的，那么就是复杂流程。即：用顺序、选择、循环不能够完全把
  解决问题的流程描述出来，可能需要用到 jump 之类的逻辑。比如一般来说网络协议基本都是复杂流程，比如口
  令校验。

- [示例: 有限状态机实现非阻塞 I/O 数据中继 v1](./Atta/code/1129-relay/README.md#v1) _(LHQ 32.2 32.3)_
- [示例: 中继引擎 v1](./Atta/code/1130-relayer-library/README.md#v1) _(LHQ 32.4 32.5 32.6)_

## I/O 多路转接 _(LHQ 32.7)_

- 监视文件描述符的行为, 当当前文件描述符发生了感兴趣的行为, 才去做后续操作.(解决盲等)
- 以下三个函数完成的功能都是一致的.
  - `select(2)`: 非常古老的一个函数，没什么什么可圈可点的优点，移植性好，但是传参部分设计的有缺陷.
    以事件为单位来组织文件描述符，该函数要掌握，但尽量用 poll(2). _(LHQ 32.7 32.8)_
  - `poll(2)`: 以文件描述符为单位来组织事件。该函数可移植性也很好，该函数一定要掌握. _(LHQ 32.9)_
  - `epoll(7)`: 各个平台有的认为 poll(2) 的效率还是不够高，各平台在做自己的 poll(2) 方言，用以改进
    poll(2) 的效率，epoll(7) 是 Linux 的方言版本，不可移植. _(LHQ 32.10)_
  - 以上三者中，select(2) 过于古老，epoll(7) 不可移植，poll(2) 是三者中最为均衡的一个函数.

- [示例: 有限状态机实现非阻塞 I/O 数据中继 v2](./Atta/code/1129-relay/README.md#v2) _(LHQ 32.7 32.8)_
- [示例: 有限状态机实现非阻塞 I/O 数据中继 v3](./Atta/code/1129-relay/README.md#v3) _(LHQ 32.9)_

- `epoll_create(2)` `epoll_ctl(2)` `epoll_wait(2)` _(LHQ 32.10)_
- [示例: 有限状态机实现非阻塞 I/O 数据中继 v4](./Atta/code/1129-relay/README.md#v4) _(LHQ 32.10)_

## 其他读写函数 _(LHQ 32.11)_

- `readv(2)`
- `writev(2)`
- `preadv(2)`
- `pwritev(2)`
- `readn()` `writen()` 是 APUE 作者自己写的函数, 因为他认为应该有这两个函数, man 手册里没有.

## 存储映射 I/O _(LHQ 32.11)_

- 把某块内存或某个文件的存储内容映射到当前进程空间里面来, 那么在当前进程当中访问一段 char 型的内容就
  如同访问那块内存一样.
- `mmap(2)`
- `munmap(2)`
- [示例: 内存映射 v1](./Atta/code/1131-use-mmap/README.md#v1) _(LHQ 32.12)_
- [示例: 进程间共享内存的实现v1](./Atta/code/1132-share-memory/README.md#v1) _(LHQ 32.12)_

## 文件锁 _(LHQ 32.13)_

- `fcntl(2)`
- `lockf(3)`
- `flock(2)`
- [示例: 线程池类写法 v3](./Atta/code/1127-thread-pool/README.md#v3) _(LHQ 32.13)_
