# 进程基础 _(LHQ 29.1)_

## 进程标识符 `pid` _(LHQ 29.1)_

- `pid` : 类型为 `pid_t` (传统来说为有符号的 16 位整型数, 大概同时可以存在三万多个进程, 若不够用的话
  可以 `typedef`, 所以现在 `pid_t` 类型在各个机器系统具体是多少位的也不清楚).
  - 进程标识符和 [文件描述符](./15101.IO基础.md#文件描述符的概念-lhq-261) 新增策略不同, 文件描述符是
    优先使用可用范围内最小的值, 而进程标识符是顺次往后使用, 即使前面有释放未使用的也不使用, 直到达到
    最大进程号, 然后再从头开始找未使用的进程号来使用.

- `ps` 命令: 打印当前系统的进程信息.
  - `ps axf` : 描述当前系统各进程.
  - `ps axm` : 以详细信息显示当前系统各进程.
  - `ps ax -L` : 以 Linux 特有的方式显示当前系统个进程信息.
  - `ps axj` : 显示当前系统作业信息.

- `getpid(2)` `getppid(2)` : man 手册说这两个函数一般会成功, 没有给出失败的情况.

## 进程的产生 _(LHQ 29.1)_

### `fork(2)` _(LHQ 29.1)_

- 和 [`setjmp(3) sigsetjmp(3)`](./15110.文件系统.md#函数跳转-lhq-2817) 类似, `fork(2)` 也是执行一次,
  返回两次, `fork(2)` 的返回是在两个不同的进程中返回.
  - 如果 `fork(2)` 执行成功, 将会在父进程中返回子进程的 `pid`, 将会在子进程中返回 0. _(LHQ 29.2)_
  - 如果 `fork(2)` 执行失败, 将会在父进程中返回 -1, 并设置 errno. _(LHQ 29.2)_

- `fork(2)` 就是复制. 当一个进程运行到 `fork(2)` 代码的时候就产生一个子进程, 该子进程和父进程几乎一
  模一样, 连代码执行到的位置都一样.
- `fork(2)` 后, 父子不一样的地方有:
  - `fork(2)` 的返回值不同
  - `pid` 不同
  - `ppid` 也不同
  - 未决信号和文件锁不继承
  - 资源利用量清零
  - 更多的不同点查看 `man 2 fork` 手册的 `DESCRIPTION` 部分

- `init 进程` : `pid` 为 1, 是所有进程的祖先进程.
- 父子进程的执行顺序由调度器的调度策略来决定, 不能凭空猜测. _(LHQ 29.2)_
- **在 `fork(2)` 之前一定要记得使用 `fflush(NULL)` 刷新所有成功打开的流.** [`exec(3)` 函数族](#exec3-函数族-lhq-297) 也一样.
- **子进程一定要有进程退出语句.**
- **父进程要为子进程做资源回收.** 查看[进程的消亡和释放资源](#进程的消亡和释放资源)
- [示例: fork(2) 的使用 v1](./Atta/code/1110-use-fork/README.md#v1) _(LHQ 29.2)_
- [示例: 筛选质数 v1 v2 v3](./Atta/code/1111-primer/README.md#筛选质数) _(LHQ 29.3 29.4)_
- `fork(2)` 和 vfork(2)` 的区别一定要看. _(LHQ 29.3 29.4)_

### `vfork(2)` (了解即可, 接近过时了) _(LHQ 29.4)_

- `fork(2)` 引入了写时复制技术后, `vfork(2)` 就很少用了.

## 进程的消亡和释放资源 _(LHQ 29.4)_

- `wait(2)` : 阻塞
- [示例: 筛选质数 v4](./Atta/code/1111-primer/README.md#v4) _(LHQ 29.5)_
- `waitpid(2)`
- `waitid(2)`
- `wait3(2)`
- `wait4(2)`
- [v3](#v3) 是筛选 201 个数字中有多少个质数, 使用了 201 个子进程, 若是筛选几百万几千万个数字中有
  多少个质数, 就要使用几百万几千万个子进程, 系统的 pid 个数是有限的资源, 所以要对产生的子进程个
  数进行限制, 限制方式: _(LHQ 29.6)_
  - 分块法
  - 交叉分配法(若使用并发来解决一个问题时用分块法和交叉分配法都可以的话, 一般来说交叉分配法优于分块
    法(本例的筛选质数不算), 90% 的情况选择交叉分配).
  - 任务池(最好) (这里涉及到竞争问题, 还没讲到, **进程间通信会**讲到竞争).

- [示例: 筛选质数 v5](./Atta/code/1111-primer/README.md#**v5**) _(LHQ 29.6)_

## `exec(3)` 函数族 _(LHQ 29.7)_

- `execl(3)` `execlp(3)` `execle(3)` `execv(3)` `execvp(3)` `execvpe(3)`
- 只有在出错的时候 `exec(3)` 函数族才会有返回值, 因为如果没出错的话新的进程映像已经替换了旧有进程映
  像, 永远不会回来了, 自然就不会有返回值了.
- 和 [`fork(2)`](#fork2-lhq-291) 一样, **在 `exec(3)` 之前注意使用 `fflush(NULL)`**.
- [示例: exec(3) 函数族的使用 v1](./Atta/code/1112-use-exec/README.md#v1) _(LHQ 29.7)_
- `few` : `fork(2)` `exec(3)` `wait(2)` 综合运用.
- [示例: exec(3) 函数族的使用 v2](./Atta/code/1112-use-exec/README.md#v2) _(LHQ 29.7)_
- `exec(3)` 中的 `argv[0]` 的名字可以随便取, `argv[X]` 也可以用其他方法封装隐藏, 这就是低级木马的隐
  藏方法, 比较高级的木马会隐藏到内核模块中. _(LHQ 29.8)_
- [示例: exec(3) 函数族的使用 v3](./Atta/code/1112-use-exec/README.md#v3) _(LHQ 29.8)_

- [示例: shell 实现 v1](./Atta/code/1113-my-shell/README.md#v1) _(LHQ 29.8 29.9)_

## 用户权限和组权限 _(LHQ 29.10)_

- `u+s` 和 `g+s`
- `getuid(2)` `geteuid(2)` `getgid(2)` `getegid(2)` `setuid(2)` `setgid(2)` `setreuid(2)`
  `setregid(2)` `seteuid(2)` `setegid(2)`

- [示例: 简易 su 命令 v1](./Atta/code/1114-my-su/README.md#v1) _(LHQ 29.10)_

## 观摩课: 解释器文件 _(LHQ 29.11 29.12)_

- 脚本文件

## `system(3)` _(LHQ 29.12)_

- 相当于对 [进程的产生](#进程的产生-lhq-291), [进程的消亡和释放资源](#进程的消亡和释放资源-lhq-294),
  [`exec(3)` 函数族](#exec3-函数族-lhq-297) 的整合封装. _(LHQ 29.1)_
  - `fork(2)` + `exec(3)` + `wait(2)`

- `system(3)` : 执行一个 shell command, 即: 调用 shell 来执行一个命令.
- [示例: system(3) 函数的使用 v1](./Atta/code/1115-use-system/README.md#v1) _(LHQ 29.12)_
- [示例: `exec(3)` 函数族的使用 v4](../1112-use-exec/README.md#v4) _(LHQ 29.12)_

## 进程会计(不作为重点, 了解即可) _(LHQ 29.12)_

- BSD 方言
- `acct(2)`

## 进程时间 _(LHQ 29.12)_

- `times(2)`

## 守护进程 _(LHQ 29.13)_

- 一般是脱离控制终端而存在.
- 一般是一个会话和进程组的 leader.
- `session 会话` : 标识为 `sid`
- `终端`
- 使用 `ps axj` 查看当前系统作业信息:
  - 守护进程的 `TTY` 一定为空(显示为 `?`).
  - 守护进程的 `PID` `PGID` `SID` 一定相同.
- `setsid(2)` : 父进程不能调用, 只能子进程调用.
- `getpgid(2)` `setpgid(2)` `getpgrp(2)` `setpgrp(2)`

- [示例: 守护进程 v1](./Atta/code/1116-my-daemon/README.md#v1) _(LHQ 29.14)_
- 单实例的守护进程: 锁文件(`/var/run/???.pid`) _(LHQ 29.15)_
- 开机启动脚本文件: `/etc/rc.d/rc.local` _(LHQ 29.15)_

## 系统日志 _(LHQ 29.15)_

- 系统日志目录: `/var/log/`, 当前系统的主日志文件为 `/var/log/messages`.
- `syslogd` 服务, 只有该服务才有权限写系统日志.
- `openlog(3)` : 与 `syslogd` 进行关联
- `syslog(3)` : 提交内容
- `closelog(3)` : 断开 `syslogd` 关联
- [示例: 守护进程 v2](./Atta/code/1116-my-daemon/README.md#v2) _(LHQ 29.15)_
