# 筛选质数

## v1

- 代码文件：
  - [main.c](./v1/main.c)

- 说明：
  - 筛选三千万到三千万零二百之间所有的质数
  - 运行: `./main` 查看输出, 筛选出的顺序是从小到大的.
  - 运行: `./main | wc -l` 按行计数, 查看筛选出了多少个质数.
  - 运行: `time ./main` 或 `bash -c "time ./main" 或`/usr/bin/time ./main` 查看程序用时.
    - `time` 是各种 shell 的内置命令, 输出形式各有不同, 同时也有一个 `/usr/bin/time` 程序.
    - `bash -c "time ./main` 指定用 bash 来运行.
    - `/usr/bin/time ./main` 使用 `/usr/bin/time` 程序来计时.
    - `time ./main > /dev/null` 只显示时间. `time` 的输出不会被重定向, 它不属于标准输出,
      `/usr/bin/time ./main` 中的 time 输出也不会被重定向.

- 资料:
  - _(LHQ 29.3)_

## v2

- 代码文件：
  - [main.c](./v2/main.c)

- 说明:
  - 筛选三千万到三千万零二百之间所有的质数
  - 对 [v1](#v1) 进行改写, 使用 201 个子进程进行并发运算.
  - **不要运行该程序, 在通常机器配置下一定会有资源报警, 内存失败, pid 耗尽之类的.** 原因看代码.
- 知识点:
  - `fork(2)`

- 资料:
  - _(LHQ 29.3)_

## v3

- 代码文件：
  - [main.c](./v3/main.c)

- 说明:
  - 筛选三千万到三千万零二百之间所有的质数
  - 对 [v2](#v2) 进行改写, 使程序可运行.
  - **子进程一定要有进程退出语句, 要不然就会出现 [v2](#v2) 那种情况.**
  - 运行: `./main` 需在终端运行, 不要在 clion 运行. 观察输出查找结果是无序的, 和 [v1](#v1) 进行比较.
  - 运行: `./main | wc -l` 按行计数, 查看筛选出了多少个质数.
  - 运行: `time ./main` 或 `bash -c "time ./main" 或`/usr/bin/time ./main` 查看程序用时, 和
    [v1](#v1) 进行比较.
  - 进程的并发数要看 cpu 核数.
  - 经常终端命令提示符先出现, 然后才会输出运行结果, 或输出一部分结果出现终端命令提示符然后继续输出运
    行结果, 是因为父进程先于子进程结束了, 添加了父进程对子进程的资源释放就好了, 见 [v4](#v4)

- 知识点:
  - `fork(2)`
  - **子进程一定要有退出语句**
  - **父进程要为子进程做资源回收.** 该例子父进程没有对子进程做资源回收, 还没学到, 默认 init 进程对所
    有子进程进行资源回收.
    - 查看 [进程的消亡和释放资源](../../../15120.进程基础.md#进程的消亡和释放资源)
    - 父进程要负责对其 `fork(2)` 的子进程进行资源释放, 若父进程退出前没有对子进程进行资源释放, 那么在
      父进程退出后, `init` 进程接收所有子进程, 这些子进程成为 `init` 的子进程, `init` 负责为这些子进程
      进行资源释放.
    - 僵尸态的进程不会占用多少资源, 甚至不会占用进程虚拟内存空间, 它就一结构体, 但是它占用着进程号, 进
      程号是有限的宝贵资源, 所以

- 资料:
  - _(LHQ 29.3 29.4)_

## v4

- 代码文件：
  - [main.c](./v4/main.c)

- 说明:
  - 筛选三千万到三千万零二百之间所有的质数
  - 对 [v3](#v3) 进行改写, 添加父进程对其子进程进行资源回收.
  - 按 [v3](#v3) 的运行方式运行.

- 知识点:
  - `wait(2)`

- 资料:
  - _(LHQ 29.5)_

## v5

- 代码文件：
  - [main.c](./v5/main.c)

- 说明:
  - 筛选三千万到三千万零二百之间所有的质数
  - 使用交叉分配法对 [v4](#v4) 进行改写.
  - 按 [v3](#v3) 的运行方式运行.
  - 此例子使用了交叉分配法进行子进程的分配, 缺陷在于产生的第一个子进程永远拿不到质数(本例比较特殊),
    最好使用任务池的分配方式, 任务池涉及到竞争问题, 这里还没学, 在进程间通信才会学.

- 知识点:
  - 生成子进程的分配方式: 分块法, 交叉分配法, 任务池

- 资料:
  - _(LHQ 29.6)_
